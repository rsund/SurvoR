SURVO84ED 81 500    81 S20                                                       *SAVE EDQMA                                                                      *LOAD EDQ                                                                        *                                                                                *MATEXT?                                                                         *                                                                                *Additional MAT #operations:                                                     *                                                                                *  1 = MAT #TRANSFORM                                                            *  2 = MAT #MULT                                                                 *  3 = MAT #SAMPLES                                                              *  4 = MAT #INDVAR                                                               *  5 = MAT #MERGE                                                                *  6 = MAT #MINDIFF                                                              *  7 = MAT #COLSORT                                                              *  8 = MAT #CRSORT                                                               *  9 = MAT #EIGEN                                                                *  A = MAT #CONVOLUTION                                                          *  B = MAT #MAXDET                                                               *  C = MAT #INTSCAL, MAT #FRAC_TO_DEC                                            *  D = MAT #SAMPLE                                                               *  E = MAT #SORT                                                                 *  F = MAT #MAGIC                                                                *  G = MAT #JACKKNIFE                                                            *  H = More MAT # operations                                                    C*                                                                                %1=TRANSFO 2=MULT 3=#SAMPLES 4=#INDVAR 5=MERGE 6=MINDIFF                         %7=COLSORT 8=CRSORT 9=EIGEN A=CONVOL B=MAXDET C=INTSCAL D=#SAMPLE                %E=SORT F=MAGIC G=#JACK H=MAT2                                                   *                                                                                *MAT2?                                                                           *                                                                                *Additional MAT #operations:                                                     *                                                                                *  1 = MAT #EIGLAN, MAT #EIGFEW                                                  *  2 = MAT #PRODDIAG                                                            C*  3 = MAT #RAO_KHATRI                                                          C*  4 = MAT #HADAMARD                                                            C*                                                                                %1=#EIGLAN 2=#PRODDIAG 3=#RAOKHAT 4=#HADAMARD                                    *                                                                                *TRANSFO?                                                                        *MAT #TRANSFORM X BY <expression(X#,I#,J#)>                                      *or                                                                              @MAT #TRANSFORM X BY Y AND <expression(X#,Y#,I#,J#)>                             *works as MAT TRANSFORM but allows a larger set of functions to be used.         *In fact, all features of the VAR operation are available                        *except those related to data sets like lags and leads, etc.                     *Thus, for example, temporary functions defined in the edit field                *library functions (on disk), and random deviates (rand function etc.)           *are permitted.                                                                  *Examples:                                                                       *m=8                                    / Generating m x m matrix A              *MAT A=ZER(m,m)                         / with all elements                      *MAT #TRANSFORM A BY probit(rand(1995)) / independently distributed as N(0,1)    *                                                                                *MAT C=ZER(m,m)                         / Generating m x m matrix C              *MAT #TRANSFORM C BY C(I#,J#)           / of binomial coefficients               *@C                                                                              @MAT #TRANSFORM C BY RECURRENCE N                                                *transforms matrix C by a recurrence relation N of two integer variables.        *N must be defined like a temporary function in editorial computing in the form  *N(m,n):=function(m,n,N(i1,j1),N(i2,j2),...) where i1,i2,...<m, j1,j2,...<=n .   *Before using this MAT #TRANSFORM operation the initial conditions               *must be given by filling certain first rows/columns/elements with               *suitable values. The starting position of iteration is supplied by              *a START=i0,j0 specification where i0,j0 are row and column indices.             *Rows and columns are implicitly labelled by 0,1,2,... (i.e. starting            *from 0 instead of 1). Operations                                                *MAT RLABELS NUM(0) TO C                                                         *MAT CLABELS NUM(0) TO C                                                         *are available for such labelling.                                               *                                                                                *If C is a column vector, also functions of one integer variable are allowed.    *@C                                                                              *........................................................................        *Example: Stirling numbers of the second kind                                    *S2(n,k):=S2(n-1,k-1)+k*S2(n-1,k)  Initial condition S2(n,1)=1                   *                                                                                *n=10 k=n             / Numbers for n=1,..,10 k=1,...,10 to be computed          *MAT A=ZER(n+1,k+1)   / Matrix A initialized by 0's                              *MAT C=CON(n,1)                                                                  *MAT A(2,2)=C         / Column 2 (corresponding to k=1) filled with 1's          *MAT RLABELS NUM(0) TO A                                                         *MAT CLABELS NUM(0) TO A                                                         */MATSHOW A,12        / See matrix A in initial state                            *                                                                                *START=2,2            / Starting point for recursion                             *MAT #TRANSFORM A BY RECURRENCE S2                                               */MATSHOW A,12345     / See the table of Stirling numbers                        *........................................................................        *@C                                                                              @MAT #TRANSFORM X BY #RAND(seed_number)                                          *works as                                                                        *MAT #TRANSFORM X BY RAND(seed_number)                                           *but is about two times faster.                                                  *                                                                                *MAT #TRANSFORM X BY #DISTR(P,seed_number)                                      C*transforms X to a random matrix with elements as a sample from                 C*a discrete distribution defined by a matrix P.                                 C*P is defined as in the command                                                 C*TRANSFORM <data> BY #DISTR(P) (See TRANSFORM?).                                C*                                                                                *@G MM                                                                           *                                                                                *MM?                                                                             *                                                                                *A = More about additional MAT #operations                                       *M = More about MAT operations                                                   %A=MATEXT M=MAT?                                                                 *                                                                                *MULT?                                                                           @MAT #MULT(C,A,B,typeA,typeB)                                                    *computes matrix C as a product of A and B (C=A*B)                               *by observing types of operands and                                              *thus avoiding multiplication of 0's.                                            *Valid types are                                                                 *D    diagonal,                                                                  *D#   #-diagonal (e.g. D3=tridiagonal),                                          *LT   lower triangular,                                                          *UT   upper triangular,                                                          *G    general.                                                                   *                                                                                *The actual type of an operand is not checked.                                   *Therefore it is possible, for example, to multiply                              *by the diagonal of a general square matrix by                                   *giving its type as D.                                                           *@G MM                                                                           *                                                                                *#SAMPLES?                                                                       @MAT #SAMPLES <matrix>,N,n,m,<rand>                                              *makes m random samples of size n from integers 1,2,...,N                        *using random number generator <rand>.                                           *The samples generated are saved as a n x m matrix file <matrix>.                *See also MAT #SAMPLE.                                                           *                                                                                *Example:                                                                        *MAT #SAMPLES LOTTO,39,7,12,rand(37952049)                                       *MAT LOAD LOTTO,123,CUR+1                                                        *                                                                                *MAT #INDVAR is a companion module to MAT #SAMPLES                               *enabling simple random sampling from Survo data files (See #INDVAR?)            *@G MM                                                                           *                                                                                *#INDVAR?                                                                        @MAT #INDVAR FROM <matrix> TO <Survo_data_file>                                  *marks subsets (samples) of size n of <Survoa_data_file>                         *by generating 0-1 indicator variables, say S1,S2,...,Sm,                        *so that Si indicates by 1's the observations whose #'s                          *appear in ascending order as the i'th row of an                                 *m x n matrix file <matrix>.                                                     *                                                                                *The actual names of the indicator variables are the same as                     *the column labels of <matrix> and they are created as                           *new variables in <Survo_data_file> if needed.                                   *                                                                                *MAT #INDVAR is a companion operation to MAT #SAMPLES                            *which generates m samples of size n from integers 1,2,...,N                     *and saves them as a m x n matrix with row labels                                *S1,S2,...,Sm.                                                                   *                                                                                *Active records of <Survo_data_file> cannot be limited                           *by IND etc. specifications.                                                     *@G MM                                                                           *                                                                                *MERGE?                                                                          @MAT #MERGE A,B TO C                                                             *combines two m x n matrices A and B to an 2m x n matrix C                       *by merging rows. Thus the rows of C will be:                                    *row 1:    row 1 of A                                                            *row 2:    row 1 of B                                                            *row 3:    row 2 of A                                                            *row 4:    row 2 of B                                                            *...       ...                                                                   *row 2m-1: row m of A                                                            *row 2m:   row m of B                                                            *@C                                                                              *MAT #MERGE A,B TO C BY mA,mB                                                    *combines an mA*k x n matrix A and an mB*k x n matrix B                          *to an (mA+mB)*k x n matrix C by merging rows of A and B                         *in blocks of rows of mA and mB, respectively.                                   *Thus the rows of C will be:                                                     *row 1:       row 1    of A                                                      *row 2:       row 2    of A                                                      *...          ...                                                                *row mA:      row mA   of A                                                      *row mA+1:    row 1    of B                                                      *row mA+2:    row 2    of B                                                      *...          ...                                                                *row mA+mB:   row mB   of B                                                      *row mA+mB+1: row mA+1 of A                                                      *row mA+mB+2: row mA+2 of A                                                      *...                                                                             *@G MM                                                                           *                                                                                *MINDIFF?                                                                        @MAT #MINDIFF(C,A,B)                                                             *computes minimal difference C of m x n matrices of                              *A=[A1,A2,...,An] and                                                            *B=[B1,B2,...,Bn]                                                                *by selecting constants s1,s2,..,sn (each either 1 or -1)                        *so that the sum of squares of the elements of                                   *C=[A1-s1*B1,A2-s1*B2,...,An-sn*Bn]                                              *is as small as possible.                                                        *@G MM                                                                           *                                                                                *COLSORT?                                                                        @MAT #COLSORT A TO B                                                             *sorts the columns of A into descending order of                                 *their sums of squares and puts the result to B.                                 *MAT #COLSORT A TO B BY MAX                                                      *sorts the columns of A into descending order of                                 *the maximum absolute values of elements and puts the result to B.               *@G MM                                                                           *                                                                                *CRSORT?                                                                         @MAT #CRSORT A TO B                                                              *sorts the columns of A into descending order of                                 *their sums of squares and after that                                            *the rows in descending order by the absolute values                             *of elements.                                                                    *@G MM                                                                           *                                                                                *EIGEN?                                                                          *MAT #EIGEN(A,D)                                                                 *computes eigenvalues D                                                          *of an n*n nonsymmetric matrix A.                                                *MAT #EIGEN(A,D,R)                                                               *computes eigenvalues D and (right) eigenvectors R                               @MAT #EIGEN(A,D,R,L)                                                             *computes also left eigenvectors L.                                              *                                                                                *D will be an n*n tridiagonal matrix where real eigenvalues                      *occupy diagonal elements while the real and imaginary parts of                  *pairs of complex eigenvalues u+iv, u-iv occupy respectively                     *the diagonal and off-diagonal corners of 2*2 blocks.                            *Afterwards an n*2 matrix D2 of real and imaginary parts of eigenvalues          *can be created by                                                               *MAT #EIGEN #VAL D,D2 .                                                          *                                                                                *Matrices A,D,R,L satisfy, for example, the equations                            *A=RDL, AR=RD, LA=DL.                                                            *@C                                                                              *The algorithm of MAT #EIGEN is based on a norm reducing Jacobi type method      *presented by P.J.Eberlein and J.Boothroyd in Handbook for Automatic             *Computation, Vol.2 (Wilkinson and Reinsch, Springer 1971, pp.327-338).          *The original algorithm has been speeded up by a factor ca. 7 by SM (1998).      *                                                                                *For a n*n symmetric matrix A it is absolutely more efficient to use             *MAT SPECTRAL DECOMPOSITION OF A TO R,D                                          *for example.                                                                    *@G MM                                                                           *                                                                                *CONVOL?                                                                         @MAT #CONVOLUTION(C,A,k)                                                         *computes k first coefficients of the convolution                                *of the columns of matrix A and saves them as                                    *a column vector C.                                                              *It is assumed that elements a0,a1,a2,... of each A column are                   *coefficients of a polynomial a0+a1*x+a2*x^2+...                                 *Default for k is k=(m-1)*n+1 where m,n are dimensions of A.                     *                                                                                *Alternatively:                                                                  *MAT #CONVOLUTION(C,A,k,N)                                                       *when A has only one column computes the N-fold convolution of this column.      *MAT #CONVOLUTION(C,A,B)                                                        C*computes the convolution C of vectors (1st columns) of A and B.                C*@C                                                                              *..................................................................              *Example: Probabilities of binomial distribution                                 *         as convolution of n Bernoulli distributions                            *p=1/3 n=13                                                                      *                                                                                *MATRIX P ///                                                                    *1-p                                                                             *p                                                                               *                                                                                *MAT SAVE P  / Save probabilities of Bernoulli distribution                      *MAT #CONVOLUTION(C,P,n+1,n)                                                     */MATSHOW C  / See binomial probabilities                                        *..................................................................              *@G MM                                                                           *                                                                                *MAXDET?                                                                         @MAT #MAXDET(C,dim,S)                                                            *finds the principal dim*dim submatrix with the maximal                          *determinant from a symmetric matrix C.                                          *Indices of rows (and columns) belonging to that                                 *submatrix are saved as a column vector S.                                       *                                                                                *The algorithms for this task are explained in                                   *S. Mustonen: Matrix computations in Survo                                       *(www.helsinki.fi/survo/matrix99.html).                                          *The extended forms of MAT #MAXDET are                                           *MAT #MAXDET(C,dim,S,0) / Exhaustive search                                      *MAT #MAXDET(C,dim,S,1) / Stepwise procedure (default)                           *MAT #MAXDET(C,dim,S,2) / Improved stepwise procedure                            *MAT #MAXDET(C,dim,S,3) / N=#_of_replicates, Random search                       *MAT #MAXDET(C,dim,S,4) / N=# Improved random search                             *@C                                                                              *Applications: See also www.helsinki.fi/survo/matrix99.html                      *MAT #MAXDET can be applied to determination of a basis of                       *the column space of a m*n matrix A as follows.                                  *If the rank of A (determined by the SVD of A) is r,                             *the most orthogonal subset of columns of A as an m*r matrix B                   *is found by the commands                                                        *MAT C=MTM(NRM(A))                                                               *MAT #MAXDET(C,r,S)  / or MAT #MAXDET(C,r,S,2), for example                      *MAT B=SUB(A,*,S)                                                                *                                                                                *If A is a factor matrix, the commands                                           *MAT C=MTM(NRM(A'))                                                              *MAT #MAXDET(C,n,S) / Find row space of A                                        *MAT B=SUB(A,S,*)                                                                *correspond to the cosine rotation of factor analysis                            *usually performed by                                                            *ROTATE A,n / METHOD=COS,0                                                       *@G MM                                                                           *                                                                                *INTSCAL?                                                                        *MAT C=#INTSCAL(A,n)                                                             *rescales the columns of A to integers by first evaluating each element          *as the n'th convergent of a continued fraction expansion of A (default          *n=10) and then finding the least common multiple of denominators.               >HELP-INTSCAL /                                             See |EXAMPLE|       C*If A is a numerical constant or a 1x1 matrix,                                   *MAT C=#INTSCAL(A,n)                                                             *evaluates continued fractions of A for up to n terms (default n=10)             *and saves both partial quotients and convergents etc. in a matrix               *file C.                                                                         >HELP-INTSCAL2 /                                            See |EXAMPLE|       C*MAT D=#FRAC_TO_DEC(C)                                                           *converts a continued fraction, represented by its partial quotients,            *and saved as the first column of matrix C, to a decimal number.                 *@G MM                                                                           *                                                                                *#SAMPLE?                                                                        *MAT C=#SAMPLE(A,m,<SRS|URS>,<rand>)                                             *makes a random sample of size m from rows of matrix A                           *using random number generator <rand>.                                           *The sample is saved as a matrix file C.                                         *By SRS a Simple Random Sample (i.e. without replacement) and                    *by URS a Unrestricted Random Sample (i.e. with replacement)                     *is generated.                                                                   >HELP-SAMPLE1 /                                             See |EXAMPLE|       C*MAT C=#SAMPLE(A,m,n,<SRS|URS>,<rand>)                                           *works similarly but makes n samples of size m from rows of A                    *as a matrix C with m*n rows.                                                    *                                                                                *See also MAT #SAMPLES                                                           *and      MAT #JACKKNIFE                                                         *@G MM                                                                           *                                                                                *#JACK?                                                                          *MAT C=#JACK(A) or MAT C=#JACKKNIFE(A)                                           *makes the n jackknife samples of the n rows of                                  *matrix A and saves them in a matrix file C.                                     *C will have n*(n-1) rows.                                                       *@G MM                                                                           *                                                                                *SORT?                                                                           *MAT C=#SORT(A,k)                                                                *sorts the rows of matrix A in ascending order of the elements of its            *k'th column.                                                                    *@G MM                                                                           *                                                                                *MAGIC?                                                                          *MAT M=#MAGIC(m)                                                                 *creates an m*m magic square matrix M of integers 1,2,...,m^2 where all column   *and row sums as well as the diagonal and skew diagonal sums are the same        *i.e. equal to m*(m^2+1)/2. The dimension m must be greater than 2.              >HELP-MAT_MAGI  /                                           See |EXAMPLE|       C*                                                                                *@G MM                                                                           *                                                                                *#EIGLAN?                                                                        *MAT #EIGLAN(A,k,S,L,n_iter,L_file)                                             C*computes k largest eigenvalues L and                                            *their eigenvectors S of a symmetric matrix A by the Lanczos method.             *n_iter (by default 10) is the number of Lanczos iterations.                     *If L_file is given, Lanczos vectors are saved as L_file.                        *                                                                                *This is an efficient method for computing a few largest eigenvalues             *and their eigenvectors when the dimension of A is large,                        *say, more than 200.                                                             *                                                                                *Reference: Golub and van Loan: Matrix computations,                             *           Chapter 9.2                                                          *@C                                                                              *MAT #EIGFEW(A,k,S,L,tol,iter)                                                  C*computes k largest eigenvalues L and corresponding eigenvectors S               *of matrix A. Parameters tol and iter are optional.                              *The simple power method is used and this command is intended for                *computing a few (k) eigenvalues and vectors when A is a large                   *square matrix. tol gives the accuracy (default tol=1e-12) and                   *iter the maximium number of iterations for each eigenvalue                      *(default iter=100).                                                             *When more accurate results are needed and A is symmetric,                       *MAT SPECTRAL DECOMPOSITION or MAT #EIGLAN should be used.                       *In non-symmetric cases MAT #EIGEN should be preferred to.                       *@G MM                                                                           *                                                                                *#PRODDIAG?                                                                      *MAT #PRODDIAG(D,A,B)                                                            *computes the diagonal elements as a vector D (mx1)                              *of matrix A*B where A is mxn and B is n*m.                                      *@G MM                                                                           *                                                                                *#RAOKHAT?                                                                       *MAT #RAO_KHATRI(C,A,B)                                                          *computes the Rao-Khatri (i.e. row-wise Kronecker) product                       *of the matrices A (m x n) and B (p x n) and saves the                           *result in the matrix C (mp x n).                                                *@G MM                                                                           *                                                                                *#HADAMARD?                                                                      *MAT #HADAMARD(C,A,B)                                                            *computes the Hadamard (elementwise) product of                                  *matrices A and B (both m x n) and saves the result                              *in the matrix C (also m x n).                                                   *@G MM                                                                           *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                END                                                                              