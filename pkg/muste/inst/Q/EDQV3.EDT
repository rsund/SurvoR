SURVO84ED 81 300    81 S20                                                       *SAVE EDQV3                                                                      *LOAD EDQ                                                                        *                                                                                *CHANCE?                                                                         *Various random variates may be generated by the VAR operation by means          *of the statistical library functions of editorial computing. (See ARIT?)        *To generate a random value from a distribution with the inverse distri-         *bution function G(), use G(rnd(0)) in the VAR operation.                        *For example, standard normal random variates are obtained by                    *N.G(0,1,rnd(0)) or faster by probit(rnd(0)). Other alternatives are:            *BIN.G(n,p,rnd(0))      binomial distribution Bin(n,p)                           *Poisson.G(a,x)         Poisson distribution Poisson(a)                          *t.G(n,rnd(0))          t distribution with n degrees of freedom                 *CHI2.G(n,rnd(0))       Chi-square distribution with n degrees of freedom        *F.G(m,n,rnd(0))        F distribution with m,n degrees of freedom               *                                                                                *For serious applications the alternative random number generator rand()         *is recommended instead of rnd().                                                *                                                                                *  R = Alternative random number generators                                      *  V = More information on VAR operation                                         *  M = MNSIMUL for fast generation of multivariate normal samples                *  T = TRANSFORM <data> BY #UNIFORM(a,b)                                         *  X = RNDTEST for testing sequences of random numbers                           *                                                                                %R=RAND V=VAR? M=MNSIMUL? T=TRANSFORM? X=RNDTEST                                 *@SELECT                                                                         *                                                                                *RAND?                                                                           *The rnd() function is a adopted as such as the Microsoft C Library              *function rand. It is based on a mixed congruential algorithm                    *     U(n)=214013U(n-1)+2531011 mod 2^31 .                                       *According to certain empirical tests with an optional RNDTEST operation         *of Survo, these numbers are rather good but not as good as those                *generated by the rand() function described below.                               *                                                                                *rand(n) where 1<=n<=2^32-1=4294967295 generates random numbers                  *according to a Combined Tausworthe generator presented by Shu Tetsuoka          *and Pierre L'Ecuyer (ACM Transactions on Modelling and Computer Simulation,     *Vol.1, No.2, 1991). The first one of the proposed three generators is           *implemented as rand().                                                          *The period length of rand() is about 10^18. In more serious simulation          *experiments where several long non-overlapping series of random numbers         *are to be guaranteed, special INSEED and OUTSEED specifications are             *available in VAR. The OUTSEED=<seed_number_file> specification                  *saves the last two seed numbers used by rand(). To continue from this           *point onwards in a new experiment, enter these seed numbers by a                *corresponding INSEED=<seed_number_file> specification.                          *When INSEED is given, the parameter n in rand(n) has no importance.             *                                                                                *@C                                                                              *Another alternative is the urand() function which corresponds to the            *classical prime modulus multiplicative linear congruential generator            *     U(n)=16807*U(n-1) mod 2^31-1                                               *suggested by Lewis, Goodman and Miller in 1969 and praised by Park              *and Miller as a minimal standard generator (see their paper "Random             *number generators: good ones are hard to find" in Communications of             *ACM, October 1988).                                                             *The period length is only 2^31-1=2147483647 (2*10^9).                           *                                                                                *A new alternative is the mrand() function using the Mersenne Twister           C*algorithm by Takuji Nishimura and Makoto Matsumoto (1998, modified             C*2002). It has a huge period 2^19937-1 (a Mersenne prime),                      C*i.e. about 10^6000.                                                            C*Currently mrand() is available in operations VAR, TRANSFORM BY #UNIFORM,       C*MAT #TRANSFORM, MNSIMUL.                                                       C*                                                                                *  V = More information on VAR operation                                         %V=VAR?                                                                          *@SELECT                                                                         *                                                                                *VARR?                                                                           @VAR <y_variable>=#<function>(<expression>) TO <data>                            *makes various special transformations of <expression> to <y_variable>.          *In most cases <expression> is simply a variable.                                *The following #<functions> are available:                                       *      #RANK   (ranks of values, tied observations with average rank)            *      #NRANK  (ranks of values, tied observations with lowest rank)             *      #NORMAL (normalized values with original mean and variance)               *      #STD    (standardized values with mean=0, std.dev=1)                      *      #CENTER (centered values with mean=0)                                     *      #PROPORTION (values divided by their total sum)                           *      #PERCENT    (100 times values divided by their total sum)                 *      #TRUNCP (outliers specified by P are replaced by missing values)          *      #WINSP  (outliers specified by P are replaced by border values)           *      #TRUNCL (outliers specified by LEVEL are replaced by missing values)      *      #WINSL  (outliers specified by LEVEL are replaced by border values)       *@C                                                                              *In #TRUNCP and #WINSP 100(1-P)% of the observations are considered              *outliers. P is given by the specification P=<value> and default is 0.95.        *In #TRUNCL and #WINSL an observation X is an outlier if                         *abs(X-mean) > level*stddev.                                                     *Level is given by the specification LEVEL=<level> and default is 1.96.          *                                                                                *For example,                                                                    *VAR Y=#PERCENT(X) TO DATA1 / gives Y values as 100*X/Sum_of_X's                 *VAR Y=#NORMAL(X) TO DATA1  / computes normalized X values as variable Y.        *                                                                                *  V = More information on VAR operation                                         %V=VAR?                                                                          *@SELECT                                                                         *                                                                                *TRANSFORM?                                                                      @TRANSFORM <data> BY <function of X>                                             *transforms all the active variables and observations (possibly limited          *by MASK, IND and CASES specifications) by <function of X> where X               *refers to one of the active variables in turn.                                  *                                                                                *TRANSFORM accepts the same functions as VAR. Thus functions                     *sqrt,log,exp,sin,cos,tan,atn,abs,int,probit, and rnd are available.             *The 'if' structure is allowed:                                                  *For example,                                                                    *TRANSFORM DATA1 BY if(X=9)then(MISSING)else(X)                                  *replaces all values '9' in active variables by missing values.                  *Library functions and the control statement 'for' are not accepted.             *Although the same transformations can be made by VAR for each variable          *separately, use of TRANSFORM saves time and effort in systematic modi-          *fications of data values.                                                       *                                                                                *For example,                                                                    *TRANSFORM YEAR88 BY log(X)                                                      *replaces data values in data YEAR88 by their natural logarithms.                *@C                                                                              *The transformed values can be saved as other (possibly new) variables           *by using TRANSFORM in an extended form                                          @TRANSFORM <data> BY <function of X> AS <letter>:<type>                          *where <letter> is a character to be placed in front of each transformed         *variable. The extension :<type> where <type> is 1,2,4 or 8 is optional          *and gives the type of new numerical variables. Default is 4.                    *For example,                                                                    *TRANSFORM YEAR88 BY log(X) AS L                                                 *VARS=Sales,Costs                                                                *makes the logarithms of variables Sales and Costs as (new) variables            *LSales and LCosts.                                                              *@C                                                                              *Also extra variables may be used in the transformation.                        C*In order to speed up the process, in such cases a specification MODE=2          *should be entered.                                                              *Example: "Proportions of events of Decathlon in percentages"                    *>COPY <Survo>\U\D\DECA.SVO TEST.SVO                                             *MASK=--AAAAAAAAAA--                                                             *MODE=2                                                                          *TRANSFORM TEST BY 1000*X/Points                                                 *FILE SHOW TEST                                                                  *@C                                                                              *The active variables and observations can be centered and standardised          *by                                                                              *TRANSFORM <data> BY CENTERING                                                   *and                                                                             *TRANSFORM <data> BY STANDARDISING (or STD),                                     *respectively.                                                                   *                                                                                *TRANSFORM <data> BY #UNIFORM(a,b)                                               *generates values from a uniform distribution on interval (a,b).                 *For continuos variables (types 4,8) values will be from a continuos             *uniform distribution on (a,b).                                                  *For discrete variables (types 1,2) values will be from a discrete               *uniform distribution with values a, a+1, a+2,..., b-1 .                         *In huge datasets this alternative is many times faster than                     *TRANSFORM <data> BY (b-a)*rand(seed)+a                                          *The pseudo-random number generator and its seed number can be selected by       *a RND specification. Example: RND=rand(1998115)                                 *@C                                                                              *@GOTO TRANSF2                                                                   *TRANSF2?                                                                        *TRANSFORM <data> BY #LINEAR(a,b) makes linear transformation X -> a*X+b .       *TRANSFORM <data> BY #DISTR(P)                                                   *                    makes random values from a discrete distribution.           *                    The values (in ascending order) and probabilities           *                    are given as a matrix file P of two columns.                >HELP-TRANSF2 /                                     See |EXAMPLE| (in Finnish)  C*In all applications of TRANSFORM where variables are transformed                *`in place' it is worthwhile to notice that transformations leading              *to decimal values (like log(X)) may be inaccurate in case of integer-           *valued variables (of type 1 or 2). In such a situation one should               *take a list of all active variables into the edit field by FILE STATUS,         *change types 1 and 2 to either 4 or 8, create (FILE CREATE) a new data          *file with this list of variables and copy (FILE COPY) the original data         *to this new data file. Transformations can then be made in the new data         *file.                                                                           *                                                                                *  M = Simulation of Markov chains by TRANSFORM                                 C*  V = More information on transformations                                       %M=MARKOVD V=VAR?                                                                *@SELECT                                                                         *                                                                                *MARKOVD?                                                                        *Simulation of Markov chains by TRANSFORM                                        *                                                                                *TRANSFORM <data> BY #MARKOV(P)                                                  *                    makes random values according to a Markov chain.            *                    Each observation (variables X1,X2,...,Xm)                   *                    will contain one realization of the chain                   *                    and starts from state given by START=i (i=1,2,...).         *                    Default is START=1.                                         *                    The transition probabilities are given as                   *                    a square matrix P.                                          *                                                                                *TRANSFORM <data> BY #MARKOV(P,<var>,<n>)                                        *                    works as the previous operation but only                    *                    saves the state of the chain in <var>                       *                    after <n> steps.                                            *                                                                                *Also Markov chains of degrees 2,3,...,8 can be simulated by the two            C*TRANSFORM operations above. Then the P matrix has dimensions m^k,m,            C*k=2,3,...,8. The start state is in these cases always the first one.           C*See an example on the next page!                                               C*@C                                                                              *.......................................................................         *Example: Simulation of a 3-state Markov chain of degree 2:                     C*MATRIX P93                                                                      *///    A   B   C                                                                *AA     0.6 0.4 0                                                                *AB     0   1   0                                                                *AC     0.2 0.2 0.6                                                              *BA     0.6 0.2 0.2                                                              *BB     0.2 0.2 0.6                                                              *BC     0.2 0.2 0.6                                                              *CA     1   0   0                                                                *CB     0   0   1                                                                *CC     0   0   1     / This is a final state!                                   *                                                                                *MAT SAVE P93                                                                    *FILE MAKE TEST,30,1000,L,S        / Space for 1000 chains of length 30          *TRANSFORM TEST BY #MARKOV(P93)    / Generating the chains RND=1111              *FILE LOAD -TEST / DELIMITER=NULL  / Loading the chains (3 first shown)          * ABBCAABBAABBAABBAAAABBBCCCCCCC                                                 * AAAABBBAAAABBACCCCCCCCCCCCCCCC                                                 * BBABBAABBAABBCBCBCBCCCCCCCCCCC                                                 *@C                                                                              *  M = More information on Markov chains                                         *  V = More information on transformations                                       %M=MARKOV? V=VAR?                                                                *                                                                                *RNDTEST?                                                                        @RNDTEST <SURVO_data>,<variable>,<output_line>                                   *makes empirical statistical tests on a series of numbers supposed to            *form a random sample from a uniform distribution in the interval (0,1).         *                                                                                *Most of these tests are explained in Volume 2 of "The Art of Programming"       *by Donald E. Knuth.                                                             *The main application of RNDTEST is testing of various random number             *generators.                                                                     *                                                                                *A standard set of tests is performed without any extra specification.           *However, If RESULTS=0, no test is performed without explicit specifica-         *tions. To select tests in a more detailed form, following specifications        *can be given.                                                                   *@C                                                                              *RNDTEST: specifications                                                         *                                                                                *SUBSAMPLES=<size>,<# of classes>                                                *The sample is divided systematically in subsamples of given <size>              *and their uniformity is tested by the standard Chi^2-test by divi-              *ding the interval (0,1) in <# of classes>.                                      *Also tests for mean=0.5 as well for the minimum ans maximum values              *in subsamples are made.                                                         *Default is SUBSAMPLES=0 (i.e. this test is omitted).                            *                                                                                *FREQUENCIES=<# of classes>,<lower limit>,<upper limit>                          *The uniformity of the total sample is tested by the Chi^2-test.                 *Default: FREQUENCIES=10,0,1                                                     *                                                                                *MAXLAG=<largest_lag>                                                            *The autocorrelations of the series are computed up to the given                 *maximum lag. Default: MAXLAG=10                                                 *@C                                                                              *RNDTEST: specifications                                                         *                                                                                *GAPTEST=<lower_limit>,<upper_limit>,<max.gap>                                   *The lengths of gaps between occurrences of values in the given range            *are computed. Default: GAPTEST=0,0.5,10                                         *                                                                                *                                                                                *PERMTEST=<# of consecutive numbers (3,4,5,6 or 7)>                              *Frequencies of different permutations of relative orderings are computed.       *Default: PERMTEST=4                                                             *                                                                                *POKER=<# of obs.>,<# of classes>,<lower limit>,<upper_limit>                    *Default: POKER=5,5,0,1                                                          *                                                                                *COUPON=<# of classes>,<max_len>,<lower limit>,<upper limit>                     *Coupon collector's test Default: COUPON=5,20,0,1                                *                                                                                *Certain run tests are performed in any case.                                    *                                                                                *R = Simulation and random numbers                                               %R=CHANCE                                                                        *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                *                                                                                END                                                                              